#!/usr/bin/env python
# -*- coding: utf-8 -*-

"""Bits & Bytes related humanization."""

suffixes = {
    'decimal': ('kB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB'),
    'binary': ('KiB', 'MiB', 'GiB', 'TiB', 'PiB', 'EiB', 'ZiB', 'YiB'),
    'gnu': "KMGTPEZY",
}


def get_naturalsize(value, binary=False, gnu=False):
    """Format a number of byteslike a human readable filesize (eg. 10 kB).  By
    default, decimal suffixes (kB, MB) are used.  Passing binary=true will use
    binary suffixes (KiB, MiB) are used and the base will be 2**10 instead of
    10**3.  If ``gnu`` is True, the binary argument is ignored and GNU-style
    (ls -sh style) prefixes are used (K, M) with the 2**10 definition.
    Non-gnu modes are compatible with jinja2's ``filesizeformat`` filter."""
    if gnu:
        suffix = suffixes['gnu']
    elif binary:
        suffix = suffixes['binary']
    else:
        suffix = suffixes['decimal']

    base = 1024 if (gnu or binary) else 1000
    bytes = float(value)

    if bytes == 1 and not gnu:
        return '1 Byte'
    elif bytes < base and not gnu:
        return '%d Bytes' % bytes
    elif bytes < base and gnu:
        return '%dB' % bytes

    l = []
    for i, s in enumerate(suffix):
        # print 'i ', i, 'suffix', s
        unit = base ** (i + 2)
        # print 'unit ', unit
        amt = (base * bytes / unit)
        l.append((amt, s))
    for c in reversed(l):
        # print c
        if c[0] > 1:
            if gnu:
                return '%.1f%s' % (c[0], c[1])
            else:
                return '%.1f %s' % (c[0], c[1])
            # print 'Final is : %.1f %s'%(c[0],c[1])


def to_bytes(sizes_list):
    """Converts to bytes

    args:        each entry in sizes_list must be of format 'value unit' (100 M)
    returns:     a list with entries in bytes, no suffix attached.
    """
    import re
    in_bytes = []
    try:
        # example patterns: 22.4 M, 22.49 KB, 40 G, 40.0 T
        regex = "^[0-9]*(\.[0-9]+)? (B|KB|K|MB|M|GB|G|TB|T)$"

        # example patterns: 22.4, 0.4, 22
        bytes_regex = "^[0-9]*(\.[0-9]+)?$"

        if not sizes_list:
            raise Exception('No valid argument provided')

        # validate sizes_list format
        for i, l in enumerate(sizes_list):
            if re.match(bytes_regex, l.strip()):
                # if the value is all numerals(no suffix), then assume it is already in bytes
                sizes_list[i] = "%s B" % l.strip()
            elif not re.match(regex, l.strip()):
                # if the value doesn't match the required format
                raise Exception("each entry in sizes_list must be of format 'value unit'. examples: 100.0 M, 100 MB, 100")

        defs = {
            'KB': 1024, 'MB': 1024**2, 'GB': 1024**3, 'TB': 1024**4,
            'K': 1024, 'M': 1024**2, 'G': 1024**3, 'T': 1024**4,
            'B': 1
            }

        in_bytes = [float(val) * defs[unit]
                    for val, unit in [l.strip().split() for l in sizes_list]]

    except Exception, e:
        return None, str(e)
    else:
        return in_bytes, None


def bytes_to_human_readable_size(in_bytes):
    """Convert the given bytes to a human friendly KB, MB, GB, or TB string

    args:       value in bytes with out any suffix
    returns:    a string containing human readable size
    """
    try:
        B = float(in_bytes)
        KB = float(1024)
        MB = float(KB ** 2)
        GB = float(KB ** 3)
        TB = float(KB ** 4)

        if B < KB:
            ret = '{0} {1}'.format(B, 'Bytes' if 0 == B > 1 else 'Byte')
        elif KB <= B < MB:
            ret = '{0:.2f} KB'.format(B / KB)
        elif MB <= B < GB:
            ret = '{0:.2f} MB'.format(B / MB)
        elif GB <= B < TB:
            ret = '{0:.2f} GB'.format(B / GB)
        elif TB <= B:
            ret = '{0:.2f} TB'.format(B / TB)

    except Exception, e:
        return None, str(e)
    else:
        return ret, None


if __name__ == '__main__':
    print get_naturalsize(6736888)

# vim: tabstop=8 softtabstop=0 expandtab ai shiftwidth=4 smarttab
