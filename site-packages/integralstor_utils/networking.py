import socket
import re
import fcntl
import struct
import os
import shutil
import time
import netifaces
import unicodedata
import pprint
import time
from os import path
from integralstor_utils import command, services_management, config

'''
  VALIDATION AND UTILITY FUNCTIONS
'''


def validate_netmask(mask):
    """Check the given netmask to see if its valid. True/False return."""
    valid = True
    try:
        nmatch = re.match(r"([0-9]+)\.([0-9]+)\.([0-9]+)\.([0-9]+)", mask)
        if nmatch:
            gr = nmatch.groups()
            if gr:
                for g in gr:
                    bits = bin(int(g))[2:].zfill(8)
                    # print int(g), bits
                    if int(g) != 0:
                        m = re.match(r'(1+)(0*)$', bits)
                        if not m:
                            # print 'invalid component - %s'%bits
                            valid = False
            else:
                valid = False
        else:
            valid = False
    except Exception, e:
        return False, "Error validating netmask : %s" % str(e)
    else:
        return valid, None


def _validate_ip_format(addr):
    """Check if the given address is a set of 4 numbers in dotted decimal."""
    ret = False
    try:
        test = re.compile('\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}')
        result = test.match(addr)
        if result:
            ret = True
        else:
            ret = False
    except Exception, e:
        return False, "Error validating IP address format : %s" % str(e)
    else:
        return ret, None


def validate_ip(addr):
    """Check if the given address is a set of 4 numbers in dotted decimal AND in the 0-255 range."""
    ret = True
    try:
        if not _validate_ip_format(addr):
            ret = False
        if ret:
            match = re.search('([0-9]+)\.([0-9]+)\.([0-9]+)\.([0-9]+)', addr)
            if match:
                ip_tup = match.groups()
                for i in range(4):
                    n = int(ip_tup[i])
                    # Some basic checks
                    if i in [0, 3]:
                        # First and last numbers cant be 0
                        if n == 0:
                            ret = False
                            break
                        if i == 3 and n == 255:
                            # Last number cant be 255
                            ret = False
                            break
                    if n < 0 or n > 255:
                        ret = False
                        break
            else:
                ret = False
    except Exception, e:
        return False, "Error validating IP address : %s" % str(e)
    else:
        return ret, None


def validate_hostname(hostname):
    """Ensure that the passed name is a valid hostname."""
    ret = True
    try:
        if len(hostname) > 255:
            ret = False
        if ret:
            if hostname.endswith("."):  # A single trailing dot is legal
                # strip exactly one dot from the right, if present
                hostname = hostname[:-1]
            disallowed = re.compile("[^A-Z\d-]", re.IGNORECASE)
            ret = all(  # Split by labels and verify individually
                (label and len(label) <= 63  # length is within proper range
                 # no bordering hyphens
                 and not label.startswith("-") and not label.endswith("-")
                 and not disallowed.search(label))  # contains only legal characters
                for label in hostname.split("."))
        if not ret:
            raise Exception('Invalid hostname')
    except Exception, e:
        return False, "Error validating hostname: %s" % str(e)
    else:
        return ret, None


def validate_ip_or_hostname(addr):
    """Some fields accept an IP or a hostname. This is a cover function to validate one or the other."""
    try:
        ret = False
        ok, err = _validate_ip_format(addr)
        if err:
            raise Exception('Error validating address : %s' % err)
        if ok:
            ok, err = validate_ip(addr)
            if err:
                raise Exception('Error validating IP address : %s' % err)
            ret = ok
        else:
            ok, err = validate_hostname(addr)
            if err:
                raise Exception('Error validating hostname : %s' % err)
            ret = ok
    except Exception, e:
        return False, "Error validating IP/hostname: %s" % str(e)
    else:
        return ret, None


def get_subnet_in_cidr_format(ip, subnet):
    """Given an IP and a subnet (as in 255.255..) string, returns the subnet info in CIDR format (as in 192.168.1.0/24)."""
    network_addr = None
    try:
        ipmatch = re.match(r"([0-9]+)\.([0-9]+)\.([0-9]+)\.([0-9]+)", ip)
        nmmatch = re.match(r"([0-9]+)\.([0-9]+)\.([0-9]+)\.([0-9]+)", subnet)
        nms = ""
        network_addr = ""
        if ipmatch and nmmatch:
            ipl = ipmatch.groups()
            nml = nmmatch.groups()
            i = 0
            while i < 4:
                binip = bin(int(ipl[i]))
                # print binip
                binnm = bin(int(nml[i]))
                nms += binnm[2:]
                # print binnm
                # print bin(int(ipl[i]) & int(nml[i]))
                network_addr += "%d" % (int(ipl[i]) & int(nml[i]))
                network_addr += '.'
                i += 1

        network_addr = network_addr[:(len(network_addr) - 1)]
        count = 0
        # print nms
        for a in nms:
            if a == '1':
                count += 1
            else:
                break
        network_addr += '/%d' % count
    except Exception, e:
        return None, "Error getting CIDR subnet : %s" % str(e)
    else:
        return network_addr, None


def can_connect(hostname, port, timeout=0.05):
    """Check connectivity to a given hostname/port combo."""
    connected = False
    try:
        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        s.settimeout(timeout)

        connected = True if s.connect_ex((hostname, port)) == 0 else False

    except Exception, e:
        return False, "Error checking connectivity: %s" % str(e)
    else:
        return connected, None


def can_ping(hostname):
    connected = False
    try:
        lines, err = command.get_command_output('ping -c 1 %s' % hostname)
        if not err:
            connected = True
    except Exception, e:
        return False, "Error checking ping : %s" % str(e)
    else:
        return connected, None


'''

  NIC BONDING FUNCTIONS

'''


def delete_bond(bond_name):
    """Delete a NIC bond."""
    modified_file_list = []
    try:
        if not bond_name:
            raise Exception('No bond name provided')

        #bond_name = unicodedata.normalize('NFKD', bond_name).encode('ascii','ignore')

        bm, err = get_bonding_masters()
        if err:
            raise Exception(err)

        if not bm or bond_name not in bm:
            raise Exception('Specified bond does not exist : %s' % err)

        bid, err = get_bonding_info_all()
        if err:
            raise Exception(err)
        if not bid:
            raise Exception('Specified bond configuration does not exist')

        init_type, err = config.get_init_type()
        if err:
            raise Exception(err)

        if init_type not in ['systemd', 'init']:
            raise Exception("No Systemd or Init found. Not removing the bond.")
        elif init_type == 'systemd':
            cmd_bond = "nmcli con delete %s" % (bond_name)
            r, err = command.get_command_output(cmd_bond)
            if err:
                raise Exception(err)

            for slave in bid['by_master'][bond_name]['slaves']:
                cmd_slave = "nmcli con delete %s-%s" % (bond_name, slave)
                r, err = command.get_command_output(cmd_slave)
                if err:
                    raise Exception(err)

                if not os.path.isfile('/etc/sysconfig/network-scripts/ifcfg-%s' % slave):
                    with open('/etc/sysconfig/network-scripts/ifcfg-%s' % slave, 'w') as f:
                        pass

            ret, err = restart_networking()
            if not ret:
                if err:
                    raise Exception(err)
                else:
                    raise Exception("Error restarting networking services")

        elif init_type == 'init':
            ret, err = command.get_command_output('ifdown %s' % bond_name)
            if err:
                raise Exception("Error shutting down network bond: %s" % err)

            if os.path.isfile('/etc/modprobe.d/bonding.conf'):
                shutil.copyfile('/etc/modprobe.d/bonding.conf',
                                '/etc/modprobe.d/BAK.bonding.conf')
            with open('/etc/modprobe.d/bonding.conf', 'w') as f:
                if 'by_master' in bid and bid['by_master']:
                    for bn, binfo in bid['by_master'].items():
                        if bn == bond_name:
                            continue
                        f.write('alias %s bonding\n' % bn)
                        #f.write('options %s mode=%d miimon=100 downdelay=200 updelay=200\n'%(bn, int(binfo['mode_num'])))
            modified_file_list.append('/etc/modprobe.d/bonding.conf')

            for slave in bid['by_master'][bond_name]['slaves']:
                if os.path.isfile('/etc/sysconfig/network-scripts/ifcfg-%s' % slave):
                    shutil.copyfile('/etc/sysconfig/network-scripts/ifcfg-%s' %
                                    slave, '/etc/sysconfig/network-scripts/BAK.ifcfg-%s' % slave)
                with open('/etc/sysconfig/network-scripts/ifcfg-%s' % slave, 'w') as f:
                    f.write('DEVICE=%s\n' % slave)
                    f.write('USERCTL=no\n')
                    f.write('ONBOOT=yes\n')
                    f.write('NM_CONTROLLED=no\n')
                    f.write('SLAVE=no\n')
                    f.write('BOOTPROTO=none\n')
                modified_file_list.append(
                    '/etc/sysconfig/network-scripts/ifcfg-%s' % slave)
            if os.path.isfile('/etc/sysconfig/network-scripts/ifcfg-%s' % bond_name):
                shutil.copyfile('/etc/sysconfig/network-scripts/ifcfg-%s' %
                                bond_name, '/etc/sysconfig/network-scripts/BAK.ifcfg-%s' % bond_name)
            if os.path.isfile('/etc/sysconfig/network-scripts/ifcfg-%s' % bond_name):
                os.remove('/etc/sysconfig/network-scripts/ifcfg-%s' %
                          bond_name)
            modified_file_list.append(
                '/etc/sysconfig/network-scripts/ifcfg-%s' % bond_name)
            # print type(bond_name)
            os.system('echo -%s > /sys/class/net/bonding_masters' % bond_name)
            ret, err = restart_networking()
            if not ret:
                if err:
                    raise Exception(err)
                else:
                    raise Exception("Error restarting networking services")
            # Now clean up all backed up files
            try:
                os.remove('/etc/modprobe.d/BAK.bonding.conf')
                os.remove(
                    '/etc/sysconfig/network-scripts/BAK.ifcfg-%s' % bond_name)
                filelist = glob.glob(
                    '/etc/sysconfig/network-scripts/BAK.ifcfg-*')
                for file in filelist:
                    os.remove(file)
            except Exception, e:
                pass

    except Exception, e:
        try:
            # Best effort cleanup
            if modified_file_list:
                for file in modified_file_list:
                    shutil.move('BAK.%s' % file, file)
        except Exception, e:
            pass
        return False, 'Error removing bond : %s' % str(e)
    else:
        return True, None


def create_bond(bond_name, slaves, mode, bootproto=None, addr_info=None):
    """Create a NIC bond."""
    modified_file_list = []
    try:
        if not slaves:
            raise Exception('No slave interfaces provided')
        if not bond_name:
            raise Exception('No bond name provided')
        if not mode or mode not in [4, 6]:
            raise Exception('Specified mode not supported')
        # print 'mode=%s'%mode

        bm, err = get_bonding_masters()
        if err:
            raise Exception(err)
        if bm and bond_name in bm:
            raise Exception('A bond of the name already exists')

        bid, err = get_bonding_info_all()
        if err:
            raise Exception(err)
        if bid:
            for slave in slaves:
                if slave in bid['by_slave']:
                    raise Exception(
                        'Interface %s is already part of another bond' % slave)

        init_type, err = config.get_init_type()
        if err:
            raise Exception(err)

        if init_type not in ['systemd', 'init']:
            raise Exception("No Systemd or Init found. Not creating the bond.")
        elif init_type == 'systemd':
            cmd_bond = "nmcli con add type bond con-name %s ifname %s mode %d" % (
                bond_name, bond_name, mode)
            r, err = command.get_command_output(cmd_bond)
            if err:
                raise Exception(err)
            else:
                for slave in slaves:
                    # regardless of returned error on executing cmd_del,
                    # cmd_down
                    cmd_del = "nmcli con del %s" % slave
                    r, err = command.get_command_output(cmd_del)

                    cmd_down = "ifdown %s" % slave
                    r, err = command.get_command_output(cmd_down)

                    cmd_slave = "nmcli con add autoconnect yes type bond-slave con-name %s-%s ifname %s master %s" % (
                        bond_name, slave, slave, bond_name)
                    r, err = command.get_command_output(cmd_slave)
                    if err:
                        raise Exception(err)
                    if_slave = "%s-%s" % (bond_name, slave)
                    cmd_con_up = "nmcli con up %s" % if_slave
                    r, err = command.get_command_output(cmd_con_up)
                    if err:
                        raise Exception(err)

        elif init_type == 'init':
            # All ok now so go ahead
            if os.path.isfile('/etc/modprobe.d/bonding.conf'):
                shutil.copyfile('/etc/modprobe.d/bonding.conf',
                                '/etc/modprobe.d/BAK.bonding.conf')
            # print 'a1'
            with open('/etc/modprobe.d/bonding.conf', 'a') as f:
                """
                if 'by_master' in bid and bid['by_master']:
                  for bn, binfo in bid['by_master'].items():
                    #print binfo
                    f.write('alias %s bonding\n'%bn)
                    #f.write('options %s mode=%d miimon=100 downdelay=200 updelay=200\n'%(bn, int(binfo['mode_num'])))
                """
                f.write('alias %s bonding\n' % bond_name)
                #f.write('options %s mode=%d miimon=100 downdelay=200 updelay=200\n'%(bond_name, mode))
            # print 'a2'

            modified_file_list.append('/etc/modprobe.d/bonding.conf')

            for slave in slaves:
                shutil.copyfile('/etc/sysconfig/network-scripts/ifcfg-%s' %
                                slave, '/etc/sysconfig/network-scripts/BAK.ifcfg-%s' % slave)
                with open('/etc/sysconfig/network-scripts/ifcfg-%s' % slave, 'w') as f:
                    f.write('DEVICE=%s\n' % slave)
                    f.write('USERCTL=no\n')
                    f.write('ONBOOT=yes\n')
                    f.write('NM_CONTROLLED=no\n')
                    f.write('MASTER=%s\n' % bond_name)
                    f.write('SLAVE=yes\n')
                    f.write('BOOTPROTO=none\n')
                modified_file_list.append(
                    '/etc/sysconfig/network-scripts/ifcfg-%s' % slave)
            if os.path.isfile('/etc/sysconfig/network-scripts/ifcfg-%s' % bond_name):
                shutil.copyfile('/etc/sysconfig/network-scripts/ifcfg-%s' %
                                bond_name, '/etc/sysconfig/network-scripts/BAK.ifcfg-%s' % bond_name)
            with open('/etc/sysconfig/network-scripts/ifcfg-%s' % bond_name, 'w') as f:
                f.write('#Generated by the IntegralStor script\n')
                f.write('DEVICE=%s\n' % bond_name)
                if not bootproto:
                    f.write('BOOTPROTO=none\n')
                elif bootproto == 'dhcp':
                    f.write('BOOTPROTO=dhcp\n')
                elif bootproto == 'static':
                    f.write('IPADDR=%s\n' % addr_info[0])
                    f.write('NETMASK=%s\n' % addr_info[1])
                    if len(addr_info) > 2:
                        f.write('GATEWAY=%s\n' % addr_info[2])
                    f.write('BOOTPROTO=none\n')
                f.write('MTU=1500\n')
                f.write('NM_CONTROLLED=no\n')
                f.write('ONBOOT=yes\n')
                f.write('USERCTL=no\n')
                f.write(
                    'BONDING_OPTS="mode=%d miimon=100 downdelay=200 updelay=200"\n' % mode)
            modified_file_list.append(
                '/etc/sysconfig/network-scripts/ifcfg-%s' % bond_name)
            os.system('echo +%s > /sys/class/net/bonding_masters' % bond_name)
            ret, err = restart_networking()
            if not ret:
                if err:
                    raise Exception(err)
                else:
                    raise Exception("Error restarting networking services")

    except Exception, e:
        try:
            if modified_file_list:
                for file in modified_file_list:
                    shutil.move('BAK.%s' % file, file)
        except Exception, e:
            pass
        return False, 'Error configuring bond : %s' % str(e)
    else:
        return True, None


def get_bonding_type(bondname):
    """Return the bonding mode of the bond."""
    mode = -1
    try:
        with open('/sys/class/net/%s/bonding/mode' % bondname, 'r') as f:
            lines = f.readlines()
            if lines:
                comps = lines[0].strip().split()
                if comps and len(comps) == 2:
                    mode_str = comps[1].strip()
                    mode = int(mode_str)
        if mode == -1:
            with open('/etc/modprobe.d/bonding.conf', 'r') as f:
                for line in f:
                    if bondname not in line:
                        continue
                    fields = line.strip().split()
                    if fields and fields[0].lower() == 'options':
                        r = re.match('[\s\S]*mode=([0-9])', line.strip())
                        if r:
                            mode_str = r.groups()[0]
                            if mode_str:
                                mode = int(mode_str)
    except Exception, e:
        # print e
        return mode, 'Error retrieving bonding type : %s' % str(e)
    else:
        return mode, None


def update_bond_ip(d):
    """Set the IP addr of the bond."""
    try:
        with open('/etc/sysconfig/network-scripts/ifcfg-bond0', 'w') as f:
            f.write('#Generated by the IntegralStor script\n')
            f.write('DEVICE=bond0\n')
            f.write('IPADDR=%s\n' % d['ip'])
            f.write('NETMASK=%s\n' % d['netmask'])
            f.write('GATEWAY=%s\n' % d['default_gateway'])
            f.write('MTU=%s\n' % d['mtu'])
            f.write('NM_CONTROLLED=no\n')
            f.write('BOOTPROTO=none\n')
            f.write('ONBOOT=yes\n')
            f.write('USERCTL=no\n')
            f.flush()
        f.close()
    except Exception, e:
        return False, 'Error setting bond IP information : %s' % str(e)
    else:
        return True, None


def get_bonding_masters():
    """Get all the bonds in existence."""
    masters = []
    try:
        if os.path.isfile('/sys/class/net/bonding_masters'):
            with open('/sys/class/net/bonding_masters', 'r') as f:
                lines = f.readlines()
                if lines:
                    for line in lines:
                        masters += (line.strip().split())
    except Exception, e:
        return None, 'Error retrieving bonding masters: %s' % str(e)
    else:
        return masters, None


def get_bonding_info(bond_name, bonding_masters=None):
    """Get information about a bond."""
    return_dict = None
    try:
        if not bond_name:
            raise Exception('No bond name specified')
        # print bond_name
        if not bonding_masters:
            bonding_masters, err = get_bonding_masters()
            if err:
                raise Exception(err)
        # print '2'
        if bonding_masters and bond_name in bonding_masters:
            return_dict = {}
            # print '3'
            with open('/sys/class/net/%s/mtu' % bond_name, 'r') as f:
                mtu = int(f.readline().strip())
                return_dict['mtu'] = mtu
            # print '4'
            '''
            with open('/sys/class/net/%s/duplex'%bond_name, 'r') as f:
            duplex = f.readline()
            if duplex:
              duplex = duplex.strip()
            return_dict['duplex'] = duplex
            #print '5'
            with open('/sys/class/net/%s/speed'%bond_name, 'r') as f:
            speed = f.readline().strip()
            return_dict['speed'] = speed
            #print '6'
            with open('/sys/class/net/%s/bonding/active_slave'%bond_name, 'r') as f:
            active_slave = f.readline().strip()
            return_dict['active_slave'] = active_slave
            ##print '7'
            '''
            with open('/sys/class/net/%s/bonding/slaves' % bond_name, 'r') as f:
                slaves_str = f.readline().strip()
                slaves = slaves_str.split()
                return_dict['slaves'] = slaves
            # print '8'
            with open('/sys/class/net/%s/bonding/mii_status' % bond_name, 'r') as f:
                mii_status = f.readline().strip()
                return_dict['mii_status'] = mii_status
            # print '9'
            with open('/sys/class/net/%s/bonding/mode' % bond_name, 'r') as f:
                mode_str = f.readline().strip()
                mode = mode_str.split()
                return_dict['mode_str'] = mode[0]
                return_dict['mode_num'] = mode[1]
            # print '10'
            with open('/sys/class/net/%s/bonding/downdelay' % bond_name, 'r') as f:
                downdelay = int(f.readline().strip())
                return_dict['downdelay'] = downdelay
            # print '11'
            with open('/sys/class/net/%s/bonding/updelay' % bond_name, 'r') as f:
                updelay = int(f.readline().strip())
                return_dict['updelay'] = updelay
            # print '12'
    except Exception, e:
        return None, 'Error retrieving bonding information: %s' % str(e)
    else:
        return return_dict, None


def get_bonding_info_all():
    """Get info about all the bonds in existence."""
    return_dict = {}
    try:
        masters, err = get_bonding_masters()
        if err:
            raise Exception(err)
        return_dict['by_master'] = {}
        return_dict['by_slave'] = {}
        if masters:
            for master in masters:
                bond, err = get_bonding_info(master, masters)
                if err:
                    raise Exception(err)
                return_dict['by_master'][master] = bond
                for slave in bond['slaves']:
                    if slave not in return_dict['by_slave']:
                        return_dict['by_slave'][slave] = master

    except Exception, e:
        return None, 'Error retrieving all bonding information: %s' % str(e)
    else:
        return return_dict, None


'''

  FUNCTIONS TO SET AND GET VARIOUS INFO FOR AN INTERFACE

'''


def get_interfaces():
    """Get info about all existing interfaces."""
    if_dict = {}
    try:
        bonding_masters = None
        bonding_slaves = None
        il = netifaces.interfaces()
        # print il
        gwd, err = get_all_gateways()
        bm, err = get_bonding_info_all()
        if err:
            raise Exception(err)
        if bm:
            bonding_slaves = bm['by_slave']
            bonding_masters = bm['by_master']
        for i in il:
            if i.startswith('lo'):
                continue
            bootproto, err = get_interface_bootproto(i)
            gateway, err = get_interface_default_gateway(i)
            is_vlan, err = is_interface_a_vlan(i)
            # print gateway, err
            addresses = netifaces.ifaddresses(i)
            d = {}
            d['gateways'] = []
            if gateway:
                d['gateways'].append((gateway, i, True))
            d['addresses'] = {}
            d['bootproto'] = bootproto
            d['vlan'] = is_vlan
            if bm and i in bm:
                d['bonding_master'] = True
            if bonding_masters and i in bonding_masters:
                d['bonding_master'] = True
            if bonding_slaves and i in bonding_slaves:
                d['slave_to'] = bonding_slaves[i]
            d['carrier_status'], err = get_interface_carrier_status(i)
            d['up_status'], err = get_interface_up_status(i)
            d['speed'], err = get_interface_speed(i)
            d['mtu'], err = get_interface_mtu(i)
            d['vlan_ids'] = []
            #d['enabled_status'], err = get_interface_enabled_status(i)

            if netifaces.AF_INET in addresses:
                d['addresses']['AF_INET'] = addresses[netifaces.AF_INET]
            if netifaces.AF_INET6 in addresses:
                d['addresses']['AF_INET6'] = addresses[netifaces.AF_INET6]
            if netifaces.AF_LINK in addresses:
                d['addresses']['AF_LINK'] = addresses[netifaces.AF_LINK]
            d['addresses']['is_sysd_ip4'] = False

            init_type, err = config.get_init_type()
            if err:
                raise Exception(err)
            if init_type == 'systemd':
                cmd = 'nmcli -t con show %s | grep -ie ip4.address | cut -d : -f 2' % i
                ret, err = command.get_command_output(cmd, shell=True)
                if ret:
                    d['addresses']['is_sysd_ip4'] = True
            if_dict[i] = d
        for ifname, id in if_dict.items():
            if id['vlan']:
                vlan_comps = ifname.split('.')
                if not vlan_comps or len(vlan_comps) != 2:
                    raise Exception('Incorrect VLAN naming : %s' % ifname)
                if vlan_comps[0] not in if_dict.keys():
                    raise Exception(
                        'Incorrectly configured VLAN : %s. Base NIC missing.' % ifname)
                if_dict[vlan_comps[0]]['vlan_ids'].append(int(vlan_comps[1]))
    except Exception, e:
        return None, 'Error retrieving interfaces : %s' % str(e)
    else:
        return if_dict, None


def get_ip_info(ifname):
    """Get the IP addr info for the interface."""
    ip_info = {}
    try:
        s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        ip_info["ipaddr"] = socket.inet_ntoa(fcntl.ioctl(
            s.fileno(), 0x8915,  struct.pack('256s', ifname[:15]))[20:24])
        ip_info["netmask"] = socket.inet_ntoa(fcntl.ioctl(
            s.fileno(), 35099, struct.pack('256s', ifname))[20:24])
        """Read the default gateway directly from /proc."""
        with open("/proc/net/route") as fh:
            for line in fh:
                fields = line.strip().split()
                if fields[1] != '00000000' or not int(fields[3], 16) & 2:
                    continue
                else:
                    ip_info["default_gateway"] = socket.inet_ntoa(
                        struct.pack("<L", int(fields[2], 16)))
                    break
    except Exception, e:
        return None, 'Error retrieving IP info : %s' % str(e)
    else:
        return ip_info, None


def get_interface_carrier_status(if_name):
    status = 'unknown'
    try:
        if os.path.isfile('/sys/class/net/%s/carrier' % if_name):
            with open('/sys/class/net/%s/carrier' % if_name, 'r') as f:
                line = f.readline()
                status = int(line.strip())
                if status == 1:
                    status = 'connected'
                elif status == 0:
                    status = 'disconnected'
    except Exception, e:
        return None, 'Error retrieving interface carrier status: %s' % str(e)
    else:
        return status, None


def get_interface_speed(if_name):
    speed = 'unknown'
    try:
        if os.path.isfile('/sys/class/net/%s/speed' % if_name):
            with open('/sys/class/net/%s/speed' % if_name, 'r') as f:
                line = f.readline()
                speed = int(line.strip())
    except Exception, e:
        return None, 'Error retrieving interface speed: %s' % str(e)
    else:
        return speed, None


def get_interface_mtu(if_name):
    mtu = 'unknown'
    try:
        if os.path.isfile('/sys/class/net/%s/mtu' % if_name):
            with open('/sys/class/net/%s/mtu' % if_name, 'r') as f:
                line = f.readline()
                mtu = int(line.strip())
    except Exception, e:
        return None, 'Error retrieving interface mtu: %s' % str(e)
    else:
        return mtu, None


def get_interface_up_status(if_name):
    status = 'unknown'
    try:
        init_type, err = config.get_init_type()
        if err:
            raise Exception(err)

        if init_type not in ['systemd', 'init']:
            raise Exception("No Systemd or Init found.")
        elif init_type == 'systemd':
            bid, err = get_bonding_info_all()
            if err:
                raise Exception(err)
            cmd = ''
            if if_name in bid['by_slave']:
                cmd = 'nmcli -t con show %s-%s | grep -ie general.state | cut -d : -f 2' % (
                    bid['by_slave'][if_name], if_name)
            else:
                cmd = 'nmcli -t con show %s | grep -ie general.state | cut -d : -f 2' % if_name

            ret, err = command.get_command_output(cmd, shell=True)
            # if err, status remains as 'unknown'
            if ret and ret[0] == 'activated':
                status = 'up'
            elif not err:
                status = 'down'

        elif init_type == 'init':
            if os.path.isfile('/sys/class/net/%s/operstate' % if_name):
                with open('/sys/class/net/%s/operstate' % if_name, 'r') as f:
                    line = f.readline()
                    status = line.strip()
    except Exception, e:
        return None, 'Error retrieving interfaces status : %s' % str(e)
    else:
        return status, None


def get_interface_enabled_status(if_name):
    status = 'unknown'
    try:
        if os.path.isfile('/sys/class/net/%s/device/enable' % if_name):
            with open('/sys/class/net/%s/device/enable' % if_name, 'r') as f:
                line = f.readline()
                st = int(line.strip())
                if st == 1:
                    status = 'enabled'
                elif st == 0:
                    status = 'disabled'
    except Exception, e:
        return None, 'Error retrieving interface enabled status: %s' % str(e)
    else:
        return status, None


def update_interface_state(if_name, state):
    try:
        if (not if_name) or (not state):
            raise Exception('Interface name or state not specified')

        if state not in ['up', 'down']:
            raise Exception('Unsupported state in state change request')

        init_type, err = config.get_init_type()
        if err:
            raise Exception(err)

        if init_type not in ['systemd', 'init']:
            raise Exception("No Systemd or Init found.")

        if init_type == 'systemd':
            cmd = 'nmcli con %s %s' % (state, if_name)
            ret, err = command.get_command_output(cmd)
            if err:
                raise Exception(err)
        else:
            cmd = 'if%s %s' % (state, if_name)
            # print cmd
            ret, err = command.get_command_output(cmd)
            if err:
                raise Exception(err)
    except Exception, e:
        return False, 'Error setting interface state: %s ' % str(e)
    else:
        return True, None


def get_interface_bootproto(if_name):
    bootproto = 'none'
    try:
        with open('/etc/sysconfig/network-scripts/ifcfg-%s' % if_name, 'r') as f:
            lines = f.readlines()
            for line in lines:
                if 'bootproto' in line.strip().lower():
                    pos = line.strip().find('=')
                    if pos != -1:
                        bootproto = line[pos + 1:].strip()
    except Exception, e:
        return None, str(e)
    else:
        return bootproto, None


def is_interface_a_vlan(if_name):
    is_vlan = False
    try:
        val = None
        with open('/etc/sysconfig/network-scripts/ifcfg-%s' % if_name, 'r') as f:
            lines = f.readlines()
            for line in lines:
                if 'vlan' in line.strip().lower():
                    pos = line.strip().find('=')
                    if pos != -1:
                        val = line[pos + 1:].strip()
        if val and val.lower() == 'yes':
            is_vlan = True
    except Exception, e:
        return None, str(e)
    else:
        return is_vlan, None


def get_interface_default_gateway(if_name):
    gateway = None
    try:
        with open('/etc/sysconfig/network-scripts/ifcfg-%s' % if_name, 'r') as f:
            lines = f.readlines()
            for line in lines:
                if 'gateway' in line.strip().lower():
                    pos = line.strip().find('=')
                    if pos != -1:
                        gateway = line[pos + 1:].strip()
    except Exception, e:
        return None, str(e)
    else:
        return gateway, None


def update_interface_ip(if_name, d):
    try:
        interfaces, err = get_interfaces()
        if err:
            raise Exception(err)
        if if_name not in interfaces:
            raise Exception('Interface not found!')
        iface = interfaces[if_name]
        if 'vlan' in iface and iface['vlan']:
            vlan = True
        else:
            vlan = False

        bm, err = get_bonding_masters()
        if err:
            raise Exception(err)
        if bm and if_name in bm:
            is_bond = True
        else:
            is_bond = False

        init_type, err = config.get_init_type()
        if err:
            raise Exception(err)

        if init_type not in ['systemd', 'init']:
            raise Exception("No Systemd or Init found. Not editing the bond.")

        if init_type == 'systemd' and is_bond is True:
            if_nm, err = get_subnet_in_cidr_format(d['ip'], d['netmask'])
            if err:
                raise Exception(err)
            if_nm_route = if_nm
            if_nm = if_nm.split("/")
            if_addr = "%s/%s" % (d['ip'], if_nm[1])
            if_gw = d['default_gateway']
            if_gw = d['default_gateway']
	    if_mtu = None
	    if 'mtu' in d and d['mtu']:
	    	if_mtu = d['mtu']
	    else:
		if_mtu = 1500

            cmd_con_down = "nmcli con down %s" % if_name
            r, err = command.get_command_output(cmd_con_down)
            if err:
                raise Exception(err)

            cmd_set_ip = 'nmcli con mod %s ipv4.method manual connection.autoconnect yes connection.autoconnect-priority 99 connection.autoconnect-slaves 1 ipv4.never-default no ipv4.addresses %s ipv4.gateway %s ipv4.routes "%s %s" 802-3-ethernet.mtu %s' % (
                if_name, if_addr, if_gw, if_nm_route, if_gw, if_mtu)
            r, err = command.get_command_output(cmd_set_ip)
            if err:
                raise Exception(err)

            cmd_con_up = "nmcli con up %s" % if_name
            r, err = command.get_command_output(cmd_con_up)
            if err:
                raise Exception(err)

            ret, err = restart_networking()
            if not ret:
                if err:
                    raise Exception(err)
                else:
                    raise Exception("Couldn't restart.")

        elif init_type == 'systemd' and is_bond is False:
            if_nm, err = get_subnet_in_cidr_format(d['ip'], d['netmask'])
            if err:
                raise Exception(err)
            if_nm_route = if_nm
            if_nm = if_nm.split("/")
            if_addr = "%s/%s" % (d['ip'], if_nm[1])
            if_gw = d['default_gateway']
	    if_mtu = None
	    if 'mtu' in d and d['mtu']:
	    	if_mtu = d['mtu']
	    else:
		if_mtu = 1500

            cmd_assert_con = 'nmcli con show %s' % if_name
            assert_con, err = command.get_command_output(cmd_assert_con)
            if err:
                cmd_con_create = 'nmcli con add type ethernet con-name %s ifname %s' % (
                    if_name, if_name)
                r, err1 = command.get_command_output(cmd_con_create)
                if err1:
                    raise Exception(err1)

            # As a best effort
            cmd_con_down = "nmcli con down %s" % if_name
            r, err = command.get_command_output(cmd_con_down)

            cmd_set_ip = 'nmcli con mod %s ipv4.method manual connection.autoconnect yes ipv4.never-default no ipv4.addresses %s ipv4.gateway %s ipv4.routes "%s %s" 802-3-ethernet.mtu %s' % (
                if_name, if_addr, if_gw, if_nm_route, if_gw, if_mtu)
            r, err = command.get_command_output(cmd_set_ip)
            if err:
                raise Exception(err)

            cmd_con_up = "nmcli con up %s" % if_name
            r, err = command.get_command_output(cmd_con_up)
            if err:
                raise Exception(err)

            ret, err = restart_networking()
            if not ret:
                if err:
                    raise Exception(err)
                else:
                    raise Exception("Couldn't restart.")

        else:
            file_name = '/etc/sysconfig/network-scripts/ifcfg-%s' % if_name

            with open(file_name, 'w') as f:
                f.write('#Generated by the IntegralStor script\n')
                f.write('DEVICE=%s\n' % if_name)
                # f.write('DEVICE=%s\n'%if_name)
                if d['addr_type'] == 'static':
                    f.write('IPADDR=%s\n' % d['ip'])
                    f.write('NETMASK=%s\n' % d['netmask'])
                    f.write('BOOTPROTO=static\n')
                else:
                    f.write('BOOTPROTO=dhcp\n')
                if 'default_gateway' in d and d['default_gateway']:
                    f.write('GATEWAY=%s\n' % d['default_gateway'])
                if 'mtu' in d:
                    f.write('MTU=%s\n' % d['mtu'])
                else:
                    f.write('MTU=1500\n')
                f.write('NM_CONTROLLED=no\n')
                f.write('ONBOOT=yes\n')
                f.write('USERCTL=no\n')
                if vlan:
                    f.write('VLAN=yes\n')
                f.flush()
            f.close()
    except Exception, e:
        return False, 'Error setting IP information : %s' % str(e)
    else:
        return True, None


def create_vlan(if_name, vlan_id):
    try:
        interfaces, err = get_interfaces()
        if err:
            raise Exception(err)
        if if_name not in interfaces:
            raise Exception('Base interface not found!')

        file_name = '/etc/sysconfig/network-scripts/ifcfg-%s.%d' % (
            if_name, vlan_id)

        with open(file_name, 'w') as f:
            f.write('#Generated by the IntegralStor script\n')
            f.write('DEVICE=%s.%d\n' % (if_name, vlan_id))
            # f.write('DEVICE=%s\n'%if_name)
            f.write('BOOTPROTO=none\n')
            f.write('MTU=1500\n')
            f.write('NM_CONTROLLED=no\n')
            f.write('ONBOOT=yes\n')
            f.write('USERCTL=no\n')
            f.write('VLAN=yes\n')
            f.flush()
        f.close()
    except Exception, e:
        return False, 'Error creating VLAN interface: %s' % str(e)
    else:
        return True, None


def delete_vlan(if_name):
    try:
        if '.' not in if_name:
            raise Exception('Invalid VLAN ID')
        if not os.path.exists('/etc/sysconfig/network-scripts/ifcfg-%s' % if_name):
            raise Exception('Specified VLAN does not exist')
        os.remove('/etc/sysconfig/network-scripts/ifcfg-%s' % if_name)
        lines, err = command.get_command_output(
            'ip link set dev %s down' % if_name)
        if err:
            raise Exception(err)
        lines, err = command.get_command_output('ip link delete %s' % if_name)
        if err:
            raise Exception(err)
    except Exception, e:
        return False, 'Error removing VLAN : %s' % str(e)
    else:
        return True, None


'''

  HOSTNAME/DOMAIN GET AND SET FUNCTIONS

'''


def update_hostname(hostname, domain_name):
    try:
        init_type, err = config.get_init_type()
        if err:
            raise Exception(err)
        if init_type == 'init':
            with open('/etc/sysconfig/network', 'w') as f:
                f.write('#Generated by the IntegralStor script\n')
                f.write('NETWORKING=yes\n')
                f.write('HOSTNAME=%s\n' % hostname)
                f.flush()
            f.close()
            ret, err = command.get_command_output('hostname %s' % hostname)
            if err:
                raise Exception(err)
        else:
            if domain_name:
                hn = '%s.%s' % (hostname, domain_name)
            else:
                hn = hostname
            ret, err = command.get_command_output(
                'hostnamectl set-hostname %s --static' % hn)
            if err:
                raise Exception(err)
            ret, err = command.get_command_output(
                'systemctl restart systemd-hostnamed')
            if err:
                raise Exception(err)
            time.sleep(5)

        if os.path.isfile('/etc/salt/minion_id'):
            os.remove('/etc/salt/minion_id')
    except Exception, e:
        return False, 'Error updating hostname : %s' % str(e)
    else:
        return True, None


def get_hostname():
    hostname = None
    try:
        hostname = socket.gethostname()
        if '.' in hostname:
            # Take only the hostname part
            dot_loc = hostname.find('.')
            hostname = hostname[:dot_loc]
    except Exception, e:
        return None, 'Error retrieving hostname: %s' % str(e)
    else:
        return hostname, None


def update_hosts_file_entry(hostname, ip):
    """Add a hostname/ip entry to the /etc/hosts file. If the IP exists with another host, replace it with this one"""
    try:
        lines = None
        with open('/etc/hosts', 'r') as f:
            lines = f.readlines()
        new_lines = []
        if lines:
            added = False
            for line in lines:
                line = line.strip()
                components = line.split()
                ipc = components[0].strip()
                if ipc[0] == '#':
                    new_lines.append('%s\n' % line)
                    continue
                if ipc == ip:
                    added = True
                    new_line = '%s %s %s.integralstor.lan\n' % (
                        ip, hostname, hostname)
                else:
                    new_line = line + '\n'
                new_lines.append(new_line)
            if not added:
                new_lines.append('%s %s %s.integralstor.lan\n' %
                                 (ip, hostname, hostname))

            if new_lines:
                with open('/tmp/integralstor_newhosts', 'w') as f1:
                    for line in new_lines:
                        f1.write(line)
            shutil.move('/tmp/integralstor_newhosts', '/etc/hosts')
    except Exception, e:
        return False, 'Error adding hosts file entry: %s' % str(e)
    else:
        return True, None


def update_domain_name(domain_name):
    try:
        with open('/etc/resolv.conf', 'r') as rf:
            lines = rf.readlines()
        with open('/tmp/integralstor_newresolv', 'w') as wf:
            if domain_name:
                wf.write('domain %s\n' % domain_name)
            for line in lines:
                res = re.match('domain[\s]+([\S\w]+)', line.strip())
                if res:
                    continue
                wf.write('%s\n' % line.strip())
            wf.flush()
            wf.close()
        shutil.move('/tmp/integralstor_newresolv', '/etc/resolv.conf')
    except Exception, e:
        return False, 'Error updating domain name : %s' % str(e)
    else:
        return True, None


def get_domain_name():
    dn = None
    try:
        hostname = socket.gethostname()
        if '.' in hostname:
            dn = hostname[hostname.find('.') + 1:]
        elif os.path.isfile('/etc/resolv.conf'):
            with open('/etc/resolv.conf', 'r') as f:
                lines = f.readlines()
                for line in lines:
                    # print 'line', line
                    if line and line.strip():
                        if line.strip()[0] == '#':
                            continue
                        res = re.match('domain[\s]+([\S\w]+)', line.strip())
                        if res:
                            gr = res.groups()
                            if gr:
                                dn = gr[0]
                                break
    except Exception, e:
        return None, 'Error retrieving domain name : %s' % str(e)
    else:
        return dn, None


'''

  SET AND GET NAME SERVERS

'''


def get_name_servers():
    name_server_list = []
    try:
        with open('/etc/resolv.conf', 'r') as f:
            for line in f:
                if line.startswith('#'):
                    continue
                fields = line.strip().split()
                if fields and fields[0].lower() == 'nameserver':
                    i = 1
                    while i < len(fields):
                        name_server_list.append(fields[i])
                        i += 1
    except Exception, e:
        return None, 'Error retrieving name servers : %s' % str(e)
    else:
        return name_server_list, None


def update_name_servers(ns_list):
    try:
        dn, err = get_domain_name()
        if err:
            raise Exception(err)
        with open('/etc/resolv.conf', 'w') as f:
            f.write('#Generated by the IntegralStor script\n')
            if dn:
                f.write('domain %s\n' % dn)
            for n in ns_list:
                if n:
                    f.write('nameserver %s\n' % n)
            f.flush()
        f.close()
    except Exception, e:
        return False, 'Error updating name servers : %s' % str(e)
    else:
        return True, None


def is_enabled_jumbo_frames(ifname):
    jumbo_frames = False
    try:
        with open('/etc/sysconfig/network-scripts/ifcfg-%s' % ifname, 'r') as f:
            for line in f:
                if line.startswith('#'):
                    continue
                fields = line.strip().split('=')
                if fields[0].lower() == 'mtu':
                    if len(fields) == 2:
                        if int(fields[1]) == 9000:
                            jumbo_frames = True
                        else:
                            jumbo_frames = False
    except Exception, e:
        return None, 'Error checking jumbo frames status : %s' % str(e)
    else:
        return jumbo_frames, None


'''

  CHANGE THE CONFIGURATION FOR A NAMED DNS SERVER

'''


def generate_default_primary_named_conf(primary_ip, primary_netmask, secondary_ip, generate_forwarders=False, forwarder_ip=None, generate_zone_file=True):
    rc = 0
    try:
        primary_cidr_netmask, err = get_subnet_in_cidr_format(
            primary_ip, primary_netmask)
        if err:
            raise Exception(err)

        with open('/etc/named.conf', 'w') as f:
            f.write('// Generated by the IntegralStor script\n')
            f.write("options {\n")
            f.write(" listen-on port 53 { any; };\n")
            f.write(" listen-on-v6 port 53 { ::1; };\n")
            f.write(' directory 	"/var/named";\n')
            f.write(' dump-file 	"/var/named/data/cache_dump.db";\n')
            f.write(' statistics-file "/var/named/data/named_stats.txt";\n')
            f.write(' memstatistics-file "/var/named/data/named_mem_stats.txt";\n')
            f.write(" allow-query     { localhost; any; };\n")
            f.write(" allow-transfer  { localhost; %s; };\n" % secondary_ip)
            if generate_forwarders:
                f.write(" forwarders    { %s; };\n" % forwarder_ip)
                f.write(" recursion yes;\n")
            else:
                f.write(" recursion no;\n")
            f.write("};\n")

            f.write("logging {\n")
            f.write(" channel default_debug {\n")
            f.write('   file "data/named.run";\n')
            f.write("   severity dynamic;\n")
            f.write(" };\n")
            f.write("};\n")

            f.write('zone "." IN {\n')
            f.write(" type hint;\n")
            f.write(' file "named.ca";\n')
            f.write("};\n")

            f.write('zone "integralstor.lan" IN {\n')
            f.write(" type master;\n")
            f.write(' file "integralstor.for";\n')
            f.write(" allow-update { localhost; %s; };\n" %
                    primary_cidr_netmask)
            f.write("};\n")

            f.write('include "/etc/named.rfc1912.zones";\n')
            f.flush()
        f.close()
        if generate_zone_file:
            rc, err = generate_default_zone_file(primary_ip, secondary_ip)
            if err:
                raise Exception(err)
            if not rc:
                raise Exception('Error generating the default zone file')
        (r, rc), err = command.execute_with_rc('service named reload')
        if err:
            raise Exception(err)
        if rc != 0:
            raise Exception("Error restarting the DNS server")
    except Exception, e:
        return False, "Error generating the master DNS configuration file : %s" % str(e)
    else:
        return True, None


def generate_default_zone_file(primary_ip, secondary_ip):
    try:
        with open('/var/named/integralstor.for', 'w') as f1:
            f1.write('$ORIGIN .\n')
            f1.write('$TTL 86400    ; 1 day\n')
            f1.write(
                'integralstor.lan        IN SOA    gridcell-pri.integralstor.lan. root.integralstor.lan. (\n')
            f1.write('                                2011071026 ; serial\n')
            f1.write(
                '                                3600       ; refresh (1 hour)\n')
            f1.write(
                '                                1800       ; retry (30 minutes)\n')
            f1.write(
                '                                604800     ; expire (1 week)\n')
            f1.write(
                '                                86400      ; minimum (1 day)\n')
            f1.write('                )\n')
            f1.write('            NS    gridcell-pri.integralstor.lan.\n')
            f1.write('            NS    gridcell-sec.integralstor.lan.\n')
            f1.write('            PTR    integralstor.lan.\n')
            f1.write('$ORIGIN integralstor.lan.\n')
            f1.write('gridcell-pri          A    %s\n' % primary_ip)
            f1.write('gridcell-sec        A    %s\n' % secondary_ip)
            f1.flush()
        f1.close()
    except Exception, e:
        return False, "Error generating zone file : %s" % str(e)
    else:
        return True, None


def generate_default_secondary_named_conf(primary_ip, secondary_netmask, secondary_ip, generate_forwarders=False, forwarder_ip=None):
    try:
        secondary_cidr_netmask, err = get_subnet_in_cidr_format(
            primary_ip, secondary_netmask)
        if err:
            raise Exception(err)

        with open('/etc/named.conf', 'w') as f:
            f.write('// Generated by the IntegralStor script\n')
            f.write('options {\n')
            f.write('  listen-on port 53 { any; };\n')
            f.write('  listen-on-v6 port 53 { ::1; };\n')
            f.write('  directory 	"/var/named";\n')
            f.write('  dump-file 	"/var/named/data/cache_dump.db";\n')
            f.write('  statistics-file "/var/named/data/named_stats.txt";\n')
            f.write('  memstatistics-file "/var/named/data/named_mem_stats.txt";\n')
            f.write(
                '  allow-query     { localhost; %s; };\n' % secondary_cidr_netmask)
            if generate_forwarders:
                f.write("   forwarders    { %s; };\n" % forwarder_ip)
                f.write('  recursion yes;\n')
            else:
                f.write('  recursion no;\n')
            f.write('};\n')

            f.write('logging {\n')
            f.write('  channel default_debug {\n')
            f.write('    file "data/named.run";\n')
            f.write('    severity dynamic;\n')
            f.write('  };\n')
            f.write('};\n')

            f.write('zone "." IN {\n')
            f.write('  type hint;\n')
            f.write('  file "named.ca";\n')
            f.write('};\n')

            f.write('zone "integralstor.lan" IN {\n')
            f.write('  type slave;\n')
            f.write('  file "slaves/integralstor.for";\n')
            f.write('  masters { %s; };\n' % primary_ip)
            f.write('};\n')
            f.write('include "/etc/named.rfc1912.zones";\n')
            f.flush()
        f.close()
        (r, rc), err = command.execute_with_rc('service named restart')
        if err:
            raise Exception(err)
        if rc != 0:
            raise Exception("Error restarting the DNS server")
    except Exception, e:
        return False, "Error generating the DNS slave configuration file : %s" % e
    else:
        return True, None


'''

  GATEWAY RELATED FUNCTIONS

'''


def get_default_gateways():
    gw_dict = {}
    try:
        gd = netifaces.gateways()
        if gd and 'default' in gd:
            if netifaces.AF_INET in gd['default']:
                gw_dict['AF_INET'] = gd['default'][netifaces.AF_INET]
            if netifaces.AF_INET6 in gd['default']:
                gw_dict['AF_INET6'] = gd['default'][netifaces.AF_INET6]
            if netifaces.AF_LINK in gd['default']:
                gw_dict['AF_LINK'] = gd['default'][netifaces.AF_LINK]

    except Exception, e:
        return None, 'Error retrieving default gateways : %s' % str(e)
    else:
        return gw_dict, None


def get_all_gateways():
    gw_dict = {}
    try:
        gd = netifaces.gateways()
        for family, gw_info in gd.items():
            if family == 'default':
                continue
            if family == netifaces.AF_INET:
                gw_dict['AF_INET'] = gw_info
            elif family == netifaces.AF_INET6:
                gw_dict['AF_INET6'] = gw_info
            elif family == netifaces.AF_LINK:
                gw_dict['AF_LINK'] = gw_info

    except Exception, e:
        return None, 'Error retrieving gateways : %s' % str(e)
    else:
        return gw_dict, None


def restart_networking():

    try:
        ret, err = services_management.update_service_status(
            'network', 'restart')
        if err:
            raise Exception(err)
    except Exception, e:
        return False, "Error restarting networking services : %s" % str(e)
    else:
        return True, None

# Pass a request.META, to this function, and enable X_Http_Forward in
# nginx,and this function will return the actual client ip of the client
# and not the gateway. Works over firewall


def get_client_ip(meta):

    try:
        user_ip = meta["HTTP_X_FORWARDED_FOR"] if "HTTP_X_FORWARDED_FOR" in meta else meta["REMOTE_ADDR"]
        return user_ip, None
    except Exception, e:
        return False, "Unable to get Client IP."


if __name__ == "__main__":
    # print validate_ip('0.1.2.3')
    # print get_bonding_type('bond0')
    # print get_ip_info('em2')
    # print get_name_servers()
    # update_hostname('check-330', 'check-dom')
    # print set_bonding_type('bond0', 6)
    # print jumbo_frames_enabled('bond0')
    # print generate_default_primary_named_conf('10.1.1.4', '255.255.255.0', '10.1.1.5')
    #set_name_servers(['192.168.1.248', '192.168.1.249', None])
    #rc = change_hosts_file_entry('gridcell-pri', '10.1.1.20', 'gridcell-pri', '10.1.1.4')
    # print rc
    r, err = get_interfaces()
    #r, err = set_admin_servers(['1.1.1.1', '1.1.1.2', '1.1.1.3'])
    #d = {'name':'eth0.5', 'ip':'192.168.1.215','netmask':'255.255.255.0','addr_type':'static'}
    #r, err = set_interface_ip_info('eth0.5', d)
    #r, err = create_vlan('eth1', 7)
    #r, err = remove_vlan('eth1.7')
    #r, err = get_default_gateways()
    #r, err = get_all_gateways()
    #r, err = get_interface_carrier_status('eth0')
    #r, err = get_interface_up_status('eth1')
    #r, err = get_bonding_masters()
    #r, err = get_bonding_info('bond1')
    #r, err = get_bonding_info_all()
    #r, err = create_bond('bond1', ['eth0', 'eth1'], 6, False, ['192.168.1.246', '255.255.255.0', '192.168.1.7'])
    #r, err = remove_bond('bond0')
    #r, err = get_domain_name()
    pp = pprint.PrettyPrinter(indent=4)
    pp.pprint(r)
    pp.pprint(err)
    # print err
    # print validate_hostname('jash-kh')
    # print regenerate_hosts_file()


# vim: tabstop=8 softtabstop=0 expandtab ai shiftwidth=4 smarttab
